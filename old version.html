<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Superhero Dodge</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background: #1a1a2e;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        #gameContainer {
            position: relative;
            border: 4px solid #e94560;
            border-radius: 8px;
            overflow: hidden;
        }

        #gameCanvas {
            display: block;
            background: linear-gradient(to bottom, #0f0c29, #302b63, #24243e);
        }

        #overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            background: rgba(0, 0, 0, 0.7);
        }

        #overlay.hidden {
            display: none;
        }

        #overlay h1 {
            color: #e94560;
            font-size: 48px;
            margin-bottom: 20px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
        }

        #overlay h2 {
            color: #fff;
            font-size: 24px;
            margin-bottom: 10px;
        }

        #overlay p {
            color: #ccc;
            font-size: 18px;
            margin-bottom: 30px;
        }

        #playButton {
            padding: 15px 40px;
            font-size: 24px;
            background: #e94560;
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
            text-transform: uppercase;
            font-weight: bold;
        }

        #playButton:hover {
            background: #ff6b6b;
            transform: scale(1.05);
        }

        #instructions {
            color: #888;
            font-size: 14px;
            margin-top: 20px;
        }

        #score {
            position: absolute;
            top: 20px;
            right: 20px;
            color: white;
            font-size: 32px;
            font-weight: bold;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
        }

        #finalScore {
            color: #ffd700;
            font-size: 36px;
            margin-bottom: 20px;
        }

        .leaderboard {
            background: rgba(0, 0, 0, 0.5);
            border-radius: 8px;
            padding: 15px 25px;
            margin: 15px 0;
            min-width: 200px;
        }

        .leaderboard h3 {
            color: #e94560;
            font-size: 18px;
            margin-bottom: 10px;
            text-align: center;
        }

        .leaderboard ol {
            list-style: none;
            padding: 0;
            margin: 0;
        }

        .leaderboard li {
            color: #fff;
            font-size: 14px;
            padding: 5px 0;
            display: flex;
            justify-content: space-between;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .leaderboard li:last-child {
            border-bottom: none;
        }

        .leaderboard .rank {
            color: #888;
            margin-right: 10px;
        }

        .leaderboard .score-value {
            color: #ffd700;
            font-weight: bold;
        }

        .new-high-score {
            color: #4ade80;
            font-size: 20px;
            margin-bottom: 10px;
            animation: pulse 1s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.6; }
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <canvas id="gameCanvas" width="800" height="500"></canvas>
        <div id="score">0</div>
        <div id="level" style="position: absolute; top: 20px; left: 20px; color: #e94560; font-size: 18px; font-weight: bold; text-shadow: 2px 2px 4px rgba(0,0,0,0.5);">Level 1</div>
        <div id="overlay">
            <h1>Superhero Dodge</h1>
            <p>Press SPACE to fly upward and avoid obstacles!</p>
            <div id="startLeaderboard"></div>
            <button id="playButton">Play</button>
            <p id="instructions">Don't hit the ground or obstacles</p>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const overlay = document.getElementById('overlay');
        const playButton = document.getElementById('playButton');
        const scoreDisplay = document.getElementById('score');

        // Game constants
        const GRAVITY = 469; // pixels per second squared
        const JUMP_VELOCITY = 216; // pixels per second upward on each press (20% faster again)
        const BASE_GAME_SPEED = 200; // pixels per second (obstacle/background speed)
        const BASE_OBSTACLE_GAP = 180; // starting gap between top and bottom obstacles
        const MIN_OBSTACLE_GAP = 120; // minimum gap at max difficulty (must fit hero + margin)
        const OBSTACLE_WIDTH = 60;
        const BASE_SPAWN_INTERVAL = 2000; // starting spawn interval in milliseconds
        const MIN_SPAWN_INTERVAL = 1000; // minimum spawn interval before level 5
        const MIN_SPAWN_INTERVAL_HARD = 700; // minimum spawn interval at max difficulty (after level 4)
        const MIN_OBSTACLE_DISTANCE = 180; // minimum pixels between obstacles (safety)
        const GROUND_HEIGHT = 60;
        const DIFFICULTY_INCREASE_INTERVAL = 10; // increase difficulty every N obstacles

        // Game state
        let hero = {
            x: 100,
            y: 250,
            width: 40,
            height: 50,
            velocityY: 0
        };

        let obstacles = [];
        let buildings = [];
        let stars = [];
        let score = 0;
        let obstaclesCleared = 0;
        let difficultyLevel = 0;
        let gameRunning = false;
        let lastTime = 0;
        let obstacleTimer = 0;
        let animationId = null;
        let lastObstacleHeight = null;
        let currentGameSpeed = BASE_GAME_SPEED;
        let currentObstacleGap = BASE_OBSTACLE_GAP;
        let currentSpawnInterval = BASE_SPAWN_INTERVAL;
        const LEADERBOARD_KEY = 'superheroFlightLeaderboard';
        const MAX_LEADERBOARD_ENTRIES = 5;

        // Leaderboard functions
        function getLeaderboard() {
            try {
                const data = localStorage.getItem(LEADERBOARD_KEY);
                return data ? JSON.parse(data) : [];
            } catch (e) {
                return [];
            }
        }

        function saveScore(newScore) {
            const leaderboard = getLeaderboard();
            leaderboard.push(Math.floor(newScore));
            leaderboard.sort((a, b) => b - a);
            const trimmed = leaderboard.slice(0, MAX_LEADERBOARD_ENTRIES);
            localStorage.setItem(LEADERBOARD_KEY, JSON.stringify(trimmed));
            return trimmed;
        }

        function isHighScore(newScore) {
            const leaderboard = getLeaderboard();
            if (leaderboard.length < MAX_LEADERBOARD_ENTRIES) return true;
            return Math.floor(newScore) > leaderboard[leaderboard.length - 1];
        }

        function renderLeaderboard(leaderboard, currentScore = null) {
            if (leaderboard.length === 0) {
                return '<div class="leaderboard"><h3>Leaderboard</h3><p style="color: #888; font-size: 14px;">No scores yet!</p></div>';
            }
            const currentScoreFloor = currentScore !== null ? Math.floor(currentScore) : null;
            const items = leaderboard.map((s, i) => {
                const isCurrentScore = currentScoreFloor !== null && s === currentScoreFloor;
                return `<li${isCurrentScore ? ' style="color: #4ade80;"' : ''}>
                    <span><span class="rank">${i + 1}.</span> ${isCurrentScore ? 'YOU' : 'Player'}</span>
                    <span class="score-value">${s}</span>
                </li>`;
            }).join('');
            return `<div class="leaderboard"><h3>Top Scores</h3><ol>${items}</ol></div>`;
        }

        // Initialize stars
        function initStars() {
            stars = [];
            for (let i = 0; i < 50; i++) {
                stars.push({
                    x: Math.random() * canvas.width,
                    y: Math.random() * (canvas.height - GROUND_HEIGHT - 100),
                    size: Math.random() * 2 + 1,
                    twinkle: Math.random() * Math.PI * 2
                });
            }
        }

        // Initialize buildings
        function initBuildings() {
            buildings = [];
            let x = 0;
            while (x < canvas.width + 200) {
                const width = Math.random() * 80 + 60;
                const height = Math.random() * 150 + 100;
                buildings.push({
                    x: x,
                    width: width,
                    height: height,
                    color: `hsl(${Math.random() * 30 + 220}, 30%, ${Math.random() * 15 + 15}%)`
                });
                x += width + Math.random() * 30;
            }
        }

        // Draw the city background
        function drawBackground(deltaTime) {
            // Sky gradient is handled by CSS, but we draw stars
            ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
            stars.forEach(star => {
                star.twinkle += deltaTime * 3;
                star.x -= currentGameSpeed * 0.1 * deltaTime;
                if (star.x < 0) star.x = canvas.width;

                const alpha = 0.5 + Math.sin(star.twinkle) * 0.5;
                ctx.globalAlpha = alpha;
                ctx.beginPath();
                ctx.arc(star.x, star.y, star.size, 0, Math.PI * 2);
                ctx.fill();
            });
            ctx.globalAlpha = 1;

            // Draw moon
            ctx.fillStyle = '#fff8dc';
            ctx.beginPath();
            ctx.arc(650, 80, 40, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = '#f0e68c';
            ctx.beginPath();
            ctx.arc(640, 75, 35, 0, Math.PI * 2);
            ctx.fill();

            // Update and draw buildings
            buildings.forEach(building => {
                building.x -= currentGameSpeed * 0.5 * deltaTime;

                // Draw building
                ctx.fillStyle = building.color;
                ctx.fillRect(
                    building.x,
                    canvas.height - GROUND_HEIGHT - building.height,
                    building.width,
                    building.height
                );

                // Draw windows
                ctx.fillStyle = 'rgba(255, 255, 150, 0.6)';
                const windowRows = Math.floor(building.height / 30);
                const windowCols = Math.floor(building.width / 20);
                for (let row = 0; row < windowRows; row++) {
                    for (let col = 0; col < windowCols; col++) {
                        if (Math.random() > 0.3) {
                            ctx.fillRect(
                                building.x + 8 + col * 18,
                                canvas.height - GROUND_HEIGHT - building.height + 15 + row * 28,
                                10,
                                15
                            );
                        }
                    }
                }
            });

            // Remove off-screen buildings and add new ones
            buildings = buildings.filter(b => b.x + b.width > 0);
            const lastBuilding = buildings[buildings.length - 1];
            if (lastBuilding && lastBuilding.x + lastBuilding.width < canvas.width + 100) {
                const width = Math.random() * 80 + 60;
                const height = Math.random() * 150 + 100;
                buildings.push({
                    x: lastBuilding.x + lastBuilding.width + Math.random() * 30,
                    width: width,
                    height: height,
                    color: `hsl(${Math.random() * 30 + 220}, 30%, ${Math.random() * 15 + 15}%)`
                });
            }

            // Draw ground
            ctx.fillStyle = '#2d2d2d';
            ctx.fillRect(0, canvas.height - GROUND_HEIGHT, canvas.width, GROUND_HEIGHT);

            // Ground details
            ctx.fillStyle = '#3d3d3d';
            ctx.fillRect(0, canvas.height - GROUND_HEIGHT, canvas.width, 5);
        }

        // Draw Superhero with rotation based on velocity
        function drawHero() {
            const x = hero.x;
            const y = hero.y;

            // Calculate rotation angle based on velocity
            // Flying up: head points NORTHEAST (up-right)
            // Falling down: head points SOUTHEAST (down-right)

            const neutralAngle = Math.PI / 4; // 45° - default slight tilt
            const maxUpAngle = Math.PI / 6; // 30° - tilt up from neutral for northeast
            const maxDownAngle = Math.PI / 3; // 60° - tilt down from neutral for southeast
            const velocityRange = 150;

            let angle;
            if (hero.velocityY < 0) {
                // Flying up - head points northeast
                const upwardProgress = Math.min(Math.abs(hero.velocityY) / velocityRange, 1);
                angle = neutralAngle - maxUpAngle * upwardProgress;
            } else {
                // Falling down - head points southeast
                const downwardProgress = Math.min(hero.velocityY / velocityRange, 1);
                angle = neutralAngle + maxDownAngle * downwardProgress;
            }

            // Save context and apply rotation
            ctx.save();
            const pivotX = x + 20;
            const pivotY = y + 30;
            ctx.translate(pivotX, pivotY);
            ctx.rotate(angle);
            ctx.translate(-pivotX, -pivotY);

            // === SUPERHERO CHARACTER ===

            // Cape (flowing behind)
            ctx.fillStyle = '#e94560';
            ctx.beginPath();
            ctx.moveTo(x + 8, y + 18);
            const capeWave = hero.velocityY < 0 ? 10 : -5;
            ctx.quadraticCurveTo(x - 10, y + 35 + capeWave, x - 5, y + 55 + capeWave);
            ctx.lineTo(x + 5, y + 50 + capeWave);
            ctx.quadraticCurveTo(x, y + 35, x + 15, y + 20);
            ctx.closePath();
            ctx.fill();

            // Body (blue suit)
            ctx.fillStyle = '#3498db';
            ctx.fillRect(x + 8, y + 18, 24, 30);

            // Chest emblem (yellow diamond with S)
            ctx.fillStyle = '#f1c40f';
            ctx.beginPath();
            ctx.moveTo(x + 20, y + 20);
            ctx.lineTo(x + 28, y + 28);
            ctx.lineTo(x + 20, y + 36);
            ctx.lineTo(x + 12, y + 28);
            ctx.closePath();
            ctx.fill();
            ctx.fillStyle = '#e94560';
            ctx.font = 'bold 10px Arial';
            ctx.fillText('S', x + 16, y + 32);

            // Head (skin)
            ctx.fillStyle = '#f5deb3';
            ctx.beginPath();
            ctx.arc(x + 20, y + 10, 11, 0, Math.PI * 2);
            ctx.fill();

            // Hero mask
            ctx.fillStyle = '#3498db';
            ctx.beginPath();
            ctx.moveTo(x + 9, y + 8);
            ctx.lineTo(x + 31, y + 8);
            ctx.lineTo(x + 28, y + 14);
            ctx.lineTo(x + 12, y + 14);
            ctx.closePath();
            ctx.fill();

            // Eyes (white with determination)
            ctx.fillStyle = '#ffffff';
            ctx.beginPath();
            ctx.ellipse(x + 15, y + 10, 4, 3, 0, 0, Math.PI * 2);
            ctx.ellipse(x + 25, y + 10, 4, 3, 0, 0, Math.PI * 2);
            ctx.fill();
            // Pupils
            ctx.fillStyle = '#2c3e50';
            ctx.beginPath();
            ctx.arc(x + 16, y + 10, 2, 0, Math.PI * 2);
            ctx.arc(x + 26, y + 10, 2, 0, Math.PI * 2);
            ctx.fill();

            // Hair (on top, behind mask)
            ctx.fillStyle = '#2c3e50';
            ctx.beginPath();
            ctx.arc(x + 20, y + 5, 8, Math.PI, 0);
            ctx.fill();

            // Jaw/chin
            ctx.fillStyle = '#f5deb3';
            ctx.beginPath();
            ctx.arc(x + 20, y + 16, 5, 0, Math.PI);
            ctx.fill();

            // Front arm (reaching forward)
            ctx.fillStyle = '#3498db';
            ctx.save();
            ctx.translate(x + 30, y + 22);
            const armAngle = hero.velocityY < 0 ? -0.3 : 0.2;
            ctx.rotate(armAngle);
            ctx.fillRect(0, -3, 16, 7);
            // Glove
            ctx.fillStyle = '#e94560';
            ctx.beginPath();
            ctx.arc(16, 0, 5, 0, Math.PI * 2);
            ctx.fill();
            // Fist
            ctx.fillStyle = '#f5deb3';
            ctx.beginPath();
            ctx.arc(18, 0, 4, 0, Math.PI * 2);
            ctx.fill();
            ctx.restore();

            // Back arm
            ctx.fillStyle = '#2980b9';
            ctx.save();
            ctx.translate(x + 10, y + 22);
            ctx.rotate(hero.velocityY < 0 ? 0.2 : -0.1);
            ctx.fillRect(-14, -3, 14, 6);
            ctx.fillStyle = '#c0392b';
            ctx.beginPath();
            ctx.arc(-14, 0, 4, 0, Math.PI * 2);
            ctx.fill();
            ctx.restore();

            // Belt
            ctx.fillStyle = '#f1c40f';
            ctx.fillRect(x + 8, y + 44, 24, 4);
            // Belt buckle
            ctx.fillStyle = '#e74c3c';
            ctx.fillRect(x + 17, y + 43, 6, 6);

            // Legs (red tights)
            ctx.fillStyle = '#c0392b';
            const legKick = hero.velocityY < 0 ? 0.15 : -0.1;
            ctx.save();
            ctx.translate(x + 14, y + 48);
            ctx.rotate(legKick);
            ctx.fillRect(-4, 0, 8, 14);
            ctx.restore();
            ctx.save();
            ctx.translate(x + 26, y + 48);
            ctx.rotate(-legKick);
            ctx.fillRect(-4, 0, 8, 14);
            ctx.restore();

            // Boots
            ctx.fillStyle = '#e94560';
            const bootOffset = hero.velocityY < 0 ? 1 : -1;
            ctx.beginPath();
            ctx.ellipse(x + 12, y + 60 + bootOffset, 6, 4, 0.1, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.ellipse(x + 28, y + 60 - bootOffset, 6, 4, -0.1, 0, Math.PI * 2);
            ctx.fill();

            ctx.restore();
        }

        // Draw obstacles (city obstacles like billboards, cranes, etc.)
        function drawObstacles() {
            obstacles.forEach(obstacle => {
                const currentTopHeight = obstacle.topHeight + (obstacle.verticalOffset || 0);
                const gap = obstacle.gap;

                // Top obstacle (hanging crane/sign)
                if (currentTopHeight > 0) {
                    // Main structure
                    ctx.fillStyle = obstacle.moving ? '#704' : '#555';
                    ctx.fillRect(obstacle.x, 0, OBSTACLE_WIDTH, currentTopHeight);

                    // Hazard stripes
                    ctx.fillStyle = obstacle.moving ? '#f0f' : '#f1c40f';
                    for (let i = 0; i < currentTopHeight; i += 20) {
                        ctx.fillRect(obstacle.x, i, OBSTACLE_WIDTH, 10);
                    }
                    ctx.fillStyle = '#333';
                    for (let i = 10; i < currentTopHeight; i += 20) {
                        ctx.fillRect(obstacle.x, i, OBSTACLE_WIDTH, 10);
                    }

                    // Bottom edge
                    ctx.fillStyle = '#e74c3c';
                    ctx.fillRect(obstacle.x - 5, currentTopHeight - 10, OBSTACLE_WIDTH + 10, 10);
                }

                // Bottom obstacle (construction barrier)
                const bottomY = currentTopHeight + gap;
                const bottomHeight = canvas.height - GROUND_HEIGHT - bottomY;
                if (bottomHeight > 0) {
                    // Main structure
                    ctx.fillStyle = obstacle.moving ? '#704' : '#666';
                    ctx.fillRect(obstacle.x, bottomY, OBSTACLE_WIDTH, bottomHeight);

                    // Warning stripes
                    ctx.fillStyle = '#e74c3c';
                    for (let i = 0; i < bottomHeight; i += 30) {
                        ctx.fillRect(obstacle.x, bottomY + i, OBSTACLE_WIDTH, 15);
                    }
                    ctx.fillStyle = '#fff';
                    for (let i = 15; i < bottomHeight; i += 30) {
                        ctx.fillRect(obstacle.x, bottomY + i, OBSTACLE_WIDTH, 15);
                    }

                    // Top edge
                    ctx.fillStyle = '#e74c3c';
                    ctx.fillRect(obstacle.x - 5, bottomY, OBSTACLE_WIDTH + 10, 10);
                }
            });
        }

        // Check collision and track cleared obstacles
        function checkCollision() {
            // Ground collision
            if (hero.y + hero.height > canvas.height - GROUND_HEIGHT) {
                return true;
            }

            // Ceiling collision
            if (hero.y < 0) {
                return true;
            }

            // Obstacle collision and scoring
            for (const obstacle of obstacles) {
                const heroRight = hero.x + hero.width;
                const heroBottom = hero.y + hero.height;
                const obstacleRight = obstacle.x + OBSTACLE_WIDTH;
                const currentTopHeight = obstacle.topHeight + (obstacle.verticalOffset || 0);

                // Check if hero has passed this obstacle (for scoring)
                if (!obstacle.cleared && obstacle.x + OBSTACLE_WIDTH < hero.x) {
                    obstacle.cleared = true;
                    obstaclesCleared++;
                    score = obstaclesCleared;
                    scoreDisplay.textContent = score;

                    // Check for difficulty increase
                    const newDifficultyLevel = Math.floor(obstaclesCleared / DIFFICULTY_INCREASE_INTERVAL);
                    if (newDifficultyLevel > difficultyLevel) {
                        difficultyLevel = newDifficultyLevel;
                        updateDifficulty();
                    }
                }

                // Check if hero overlaps with obstacle horizontally
                if (heroRight > obstacle.x && hero.x < obstacleRight) {
                    // Check top obstacle
                    if (hero.y < currentTopHeight) {
                        return true;
                    }
                    // Check bottom obstacle
                    const bottomY = currentTopHeight + obstacle.gap;
                    if (heroBottom > bottomY) {
                        return true;
                    }
                }
            }

            return false;
        }

        // Update difficulty settings
        function updateDifficulty() {
            // Each level increases difficulty
            const maxLevels = 10;
            const progress = Math.min(difficultyLevel / maxLevels, 1);

            // Decrease gap (180 -> 120)
            currentObstacleGap = BASE_OBSTACLE_GAP - (BASE_OBSTACLE_GAP - MIN_OBSTACLE_GAP) * progress;

            // Increase game speed (200 -> 320)
            currentGameSpeed = BASE_GAME_SPEED + 120 * progress;

            // Calculate minimum safe spawn interval based on current speed
            // Ensures player always has enough time to navigate between obstacles
            const minSafeInterval = (MIN_OBSTACLE_DISTANCE / currentGameSpeed) * 1000;

            // Decrease spawn interval based on level
            if (difficultyLevel < 4) {
                // Levels 1-4: Gradual decrease (2000ms -> 1200ms)
                const earlyProgress = difficultyLevel / 4;
                currentSpawnInterval = BASE_SPAWN_INTERVAL - (BASE_SPAWN_INTERVAL - 1200) * earlyProgress;
            } else {
                // Level 5+: Obstacles get closer together
                // Progress from level 5 (0) to level 10 (1)
                const lateProgress = Math.min((difficultyLevel - 4) / 6, 1);
                // Decrease from 1200ms toward MIN_SPAWN_INTERVAL_HARD (700ms)
                const targetInterval = 1200 - (1200 - MIN_SPAWN_INTERVAL_HARD) * lateProgress;
                // But never less than the safe minimum
                currentSpawnInterval = Math.max(targetInterval, minSafeInterval);
            }

            // Update level display
            document.getElementById('level').textContent = `Level ${difficultyLevel + 1}`;
        }

        // Spawn obstacle with progressive difficulty
        function spawnObstacle() {
            // Calculate safe boundaries - ensure hero can always fit through
            const minTop = 60; // Minimum top obstacle height
            const maxTop = canvas.height - GROUND_HEIGHT - currentObstacleGap - 60;

            // Ensure maxTop is always greater than minTop
            const safeMaxTop = Math.max(minTop + 20, maxTop);
            const midPoint = (minTop + safeMaxTop) / 2;

            // Calculate height variance based on difficulty level
            const maxLevels = 10;
            const difficultyProgress = Math.min(difficultyLevel / maxLevels, 1);

            // Calculate how much height change is safe based on spawn interval
            // Closer obstacles = less height change allowed
            const spawnIntervalRatio = currentSpawnInterval / BASE_SPAWN_INTERVAL;
            const maxHeightChangeMultiplier = Math.max(0.4, spawnIntervalRatio); // Min 40% even at fastest

            // At low difficulty, obstacles spawn near middle
            // At high difficulty, obstacles can spawn anywhere and alternate high/low
            const rangeFromMiddle = (safeMaxTop - minTop) / 2;
            let allowedRange = rangeFromMiddle * (0.3 + 0.7 * difficultyProgress);

            // Limit height change when obstacles are close together
            const maxHeightChange = allowedRange * maxHeightChangeMultiplier;

            let topHeight;

            if (difficultyProgress > 0.3 && lastObstacleHeight !== null) {
                // Make obstacles alternate between high and low
                const wasHigh = lastObstacleHeight < midPoint;

                if (wasHigh) {
                    // Move toward lower position (higher topHeight value)
                    const targetHeight = lastObstacleHeight + Math.random() * maxHeightChange + maxHeightChange * 0.3;
                    topHeight = Math.min(targetHeight, safeMaxTop);
                } else {
                    // Move toward higher position (lower topHeight value)
                    const targetHeight = lastObstacleHeight - Math.random() * maxHeightChange - maxHeightChange * 0.3;
                    topHeight = Math.max(targetHeight, minTop);
                }
            } else {
                topHeight = midPoint + (Math.random() * 2 - 1) * allowedRange;
            }

            // Clamp to valid range
            topHeight = Math.max(minTop, Math.min(safeMaxTop, topHeight));

            // Final safety check: if obstacles are very close, limit height difference
            if (lastObstacleHeight !== null && currentSpawnInterval < 900) {
                const maxSafeChange = 100; // Max 100px change when obstacles are close
                const heightDiff = topHeight - lastObstacleHeight;
                if (Math.abs(heightDiff) > maxSafeChange) {
                    topHeight = lastObstacleHeight + Math.sign(heightDiff) * maxSafeChange;
                    topHeight = Math.max(minTop, Math.min(safeMaxTop, topHeight));
                }
            }

            lastObstacleHeight = topHeight;

            // Determine if obstacle should move (starts at level 3, increases chance)
            // Reduce moving chance when obstacles are close together
            const baseMovingChance = difficultyLevel >= 3 ? Math.min((difficultyLevel - 2) * 0.15, 0.5) : 0;
            const movingChance = baseMovingChance * Math.max(0.5, spawnIntervalRatio);
            const isMoving = Math.random() < movingChance;

            // Calculate safe movement range - obstacle must always remain passable
            const gapTop = topHeight;
            const gapBottom = topHeight + currentObstacleGap;
            const maxMoveUp = Math.min(gapTop - minTop, 25 + difficultyLevel * 3);
            const maxMoveDown = Math.min(canvas.height - GROUND_HEIGHT - gapBottom - 30, 25 + difficultyLevel * 3);
            const safeMoveRange = Math.min(maxMoveUp, maxMoveDown, 35); // Cap movement range

            obstacles.push({
                x: canvas.width,
                topHeight: topHeight,
                gap: currentObstacleGap,
                cleared: false,
                moving: isMoving,
                verticalOffset: 0,
                moveDirection: Math.random() > 0.5 ? 1 : -1,
                moveSpeed: 25 + difficultyLevel * 6, // Speed increases with difficulty
                moveRange: Math.max(8, safeMoveRange) // Ensure some movement but keep it safe
            });
        }

        // Update game state
        function update(deltaTime) {
            if (!gameRunning) return;

            // Always apply gravity
            hero.velocityY += GRAVITY * deltaTime;

            // Update hero position
            hero.y += hero.velocityY * deltaTime;

            // Update obstacles
            obstacles.forEach(obstacle => {
                obstacle.x -= currentGameSpeed * deltaTime;

                // Update moving obstacles
                if (obstacle.moving) {
                    obstacle.verticalOffset += obstacle.moveDirection * obstacle.moveSpeed * deltaTime;

                    // Calculate current position limits to ensure obstacle stays passable
                    const currentTop = obstacle.topHeight + obstacle.verticalOffset;
                    const currentBottom = currentTop + obstacle.gap;
                    const minAllowedTop = 30;
                    const maxAllowedBottom = canvas.height - GROUND_HEIGHT - 30;

                    // Reverse direction at bounds or if obstacle would become impossible
                    if (Math.abs(obstacle.verticalOffset) > obstacle.moveRange ||
                        currentTop < minAllowedTop ||
                        currentBottom > maxAllowedBottom) {
                        obstacle.moveDirection *= -1;
                        // Clamp the offset to safe bounds
                        if (currentTop < minAllowedTop) {
                            obstacle.verticalOffset = minAllowedTop - obstacle.topHeight;
                        } else if (currentBottom > maxAllowedBottom) {
                            obstacle.verticalOffset = maxAllowedBottom - obstacle.gap - obstacle.topHeight;
                        } else {
                            obstacle.verticalOffset = Math.sign(obstacle.verticalOffset) * obstacle.moveRange;
                        }
                    }
                }
            });

            // Remove off-screen obstacles
            obstacles = obstacles.filter(o => o.x + OBSTACLE_WIDTH > 0);

            // Spawn new obstacles
            obstacleTimer += deltaTime * 1000;
            if (obstacleTimer >= currentSpawnInterval) {
                // Check if there's enough space from the last obstacle
                const lastObstacle = obstacles[obstacles.length - 1];
                const canSpawn = !lastObstacle || (canvas.width - lastObstacle.x) >= MIN_OBSTACLE_DISTANCE;

                if (canSpawn) {
                    spawnObstacle();
                    obstacleTimer = 0;
                }
            }

            // Check for collision (also handles scoring)
            if (checkCollision()) {
                gameOver();
            }
        }

        // Draw everything
        function draw(deltaTime) {
            // Clear canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Draw background
            drawBackground(deltaTime);

            // Draw obstacles
            drawObstacles();

            // Draw hero
            drawHero();
        }

        // Game loop
        function gameLoop(timestamp) {
            const deltaTime = (timestamp - lastTime) / 1000;
            lastTime = timestamp;

            update(deltaTime);
            draw(deltaTime);

            if (gameRunning) {
                animationId = requestAnimationFrame(gameLoop);
            }
        }

        // Start game
        function startGame() {
            // Reset game state
            hero.y = 250;
            hero.velocityY = 0;
            obstacles = [];
            score = 0;
            obstaclesCleared = 0;
            difficultyLevel = 0;
            obstacleTimer = 0;
            lastObstacleHeight = null;
            gameRunning = true;

            // Reset difficulty settings
            currentGameSpeed = BASE_GAME_SPEED;
            currentObstacleGap = BASE_OBSTACLE_GAP;
            currentSpawnInterval = BASE_SPAWN_INTERVAL;

            initStars();
            initBuildings();

            overlay.classList.add('hidden');
            scoreDisplay.textContent = '0';
            document.getElementById('level').textContent = 'Level 1';

            lastTime = performance.now();
            animationId = requestAnimationFrame(gameLoop);
        }

        // Game over
        function gameOver() {
            gameRunning = false;
            if (animationId) {
                cancelAnimationFrame(animationId);
            }

            const wasHighScore = isHighScore(score);
            const leaderboard = saveScore(score);
            const highScoreMessage = wasHighScore ? '<div class="new-high-score">NEW HIGH SCORE!</div>' : '';

            overlay.innerHTML = `
                <h1>Game Over</h1>
                ${highScoreMessage}
                <div id="finalScore">Score: ${Math.floor(score)} obstacles</div>
                <div style="color: #e94560; font-size: 18px; margin-bottom: 15px;">Reached Level ${difficultyLevel + 1}</div>
                ${renderLeaderboard(leaderboard, score)}
                <button id="playButton">Play Again</button>
                <p id="instructions">Press SPACE or click to try again</p>
            `;
            overlay.classList.remove('hidden');

            document.getElementById('playButton').addEventListener('click', startGame);
        }

        // Handle input - each press gives a fresh upward boost
        function handleJump() {
            if (!gameRunning) {
                startGame();
            } else {
                hero.velocityY = -JUMP_VELOCITY; // Each press sets upward velocity
            }
        }

        // Event listeners
        document.addEventListener('keydown', (e) => {
            if (e.code === 'Space') {
                e.preventDefault();
                handleJump();
            }
        });

        playButton.addEventListener('click', startGame);

        // Show leaderboard on start screen
        function updateStartLeaderboard() {
            const leaderboardDiv = document.getElementById('startLeaderboard');
            if (leaderboardDiv) {
                leaderboardDiv.innerHTML = renderLeaderboard(getLeaderboard());
            }
        }

        // Initial draw
        initStars();
        initBuildings();
        draw(0);
        updateStartLeaderboard();
    </script>
</body>
</html>
